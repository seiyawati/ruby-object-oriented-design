# 第3章 依存関係を管理する

オブジェクトが実行する振る舞いは、  
1. オブジェクト自身が実装している振る舞い
2. オブジェクト自身が継承している振る舞い
3. 他のオブジェクトに実装されている振る舞い

の3つに分類できる。  
このうち1つ目については、前章で扱った。継承については第6章で扱う。  
この章では、3つ目の、他のオブジェクトに実装されている振る舞いについて、論じていく。

前章で取り扱ったように、適切に設計されたオブジェクトは単一の責任を持つ。  
そのため、オブジェクトは他のオブジェクトと共同作業をすることで、アプリケーション全体の目的を果たす。  
しかし、共同作業をするためには、他のオブジェクトのことを知っている必要がある。  
この「知っている」ということが依存を作り出し、管理されていない依存関係はアプリケーションの変更容易性を大きく損ねてしまう。

## 3.1 依存関係を理解する

依存とは、一方のオブジェクトに変更を加えたときに他方のオブジェクトも変更せざるを得ない恐れがあること。  
例えば以下のGearは、Wheelに対して依存している。Wheelを変更したとき、Gearへの変更も強制される恐れがある。
```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end

  def ratio
    chainring / cog.to_f
  end
end

class Wheel
  attr_reader :rim, :tire
  def initialize(rim, tire)
    @rim = rim
    @tire = tire
  end

  def diameter
    rim + (tire * 2)
  end

  def circumference
    diameter * Math::PI
  end
end

p Gear.new(52, 11, 26, 1.5).gear_inches # 137.0909090909091
```
このGearのWheelに対する依存は、少なくとも4つある。
- 他のクラスの名前
  - Gearは、Wheelという名前のクラスが存在することを予想している
- self以外のどこかに送ろうとするメッセージの名前
  - Gearは、Wheelのインスタンスがdiameterに応答することを予想している
- メッセージが要求する引数
  - Gearは、Wheel.newにrimとtireが必要なことを知っている
- それら引数の順番
  - Gearは、Wheel.newの最初の引数がrimで、2番目がtireであることを知っている

共同作業をする以上、依存関係を完全に無くすことは出来ない。  
しかし上記の依存のほとんどは、コードの書き方が悪いために発生してしまった、無用な依存である。  
このようなコードでは、些細な変更が次々とアプリケーション内を伝播していき、多くの変更を強制されてしまう。  
依存関係は最低限に保たないといけない。

GearがWheelのことを知れば知るほど、両者間の結合は強くなっていき、1つのオブジェクトのように振る舞うようになる。  

管理されていない依存関係はアプリケーションを複雑に絡み合ったものに変えてしまい、いずれ、一から書き直したほうがマシだとさえ思うようなものにしてしまう。  

依存関係の1つとして、コードに対するテストの依存がある。  
テストに慣れていないうちは、コードと過度に結合したテストを書いてしまいがちである。  
このようなテストは、コードをリファクタリングする度に壊れてしまう。コードの変更がテストに次々と伝播していくから。  
テストの設計については第9章で扱う。

依存関係を回避することは難しくない。  
そのための最初のステップとして、依存関係に対する理解を深める。

## 3.2 疎結合なコードを書く

上述した3_1_1.rbの大きな問題点は、gear_inchesメソッド内でWheelをハードコーディングしてしまっていること。  
このせいで、不要な依存が発生してしまっている。  
GearとWheelが必要以上に結びついていることで、Gearの再利用性や変更容易性が下がってしまっている。

Gearにとって重要なのは、Wheelというクラスではなくdiameterというメッセージ。diameterというメッセージに応答してくれるのであれば、どんなオブジェクトでも構わない。  
だから本来、Wheelというクラス名も、それを初期化するためにrimとtireが必要だということも、Gearは知る必要がない。  

以下のように変更することで、これを改善できる。
```diff
@@ -1,14 +1,13 @@
 class Gear
-  attr_reader :chainring, :cog, :rim, :tire
-  def initialize(chainring, cog, rim, tire)
+  attr_reader :chainring, :cog, :wheel
+  def initialize(chainring, cog, wheel)
     @chainring = chainring
     @cog = cog
-    @rim = rim
-    @tire = tire
+    @wheel = wheel
   end
 
   def gear_inches
-    ratio * Wheel.new(rim, tire).diameter
+    ratio * wheel.diameter
   end
 
   def ratio
@@ -32,4 +31,4 @@ class Wheel
   end
 end
 
-p Gear.new(52, 11, 26, 1.5).gear_inches # 137.0909090909091
+p Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches # 137.0909090909091
```

この改善によって、GearはWheelに依存しなくなった。  
初期化の際に渡されたオブジェクトを@wheel変数に保存しているが、このオブジェクトはWheelのインスタンスである必要はない。diameterに応答できるオブジェクトであるなら、なんでもよい。  
この変更で、Wheelインスタンス以外のオブジェクトとも共同作業できるようになり、Gearの再利用性が高まった。

このテクニックを依存オブジェクトの注入と呼ぶ。  
依存を外に切り出して、引数で渡して注入する形に変える。  
そうすることで、注入される側のクラス（今回の例だとGear）は、注入するオブジェクト（今回の例だとWheel）についての知識を持たずに済み、疎結合なクラスになる。

### 依存を隔離する

不必要な依存を全て取り除ければ完璧だが、現実的には難しいことも多い。  
そのようなときでも、出来ることはある。  
不必要な依存をクラスの中で隔離するだけでも、状況は改善する。

例えば、インスタンス変数の作成を分離してしまう。  
Gearの例で言えば、Wheelを注入する形に変更することが出来ないのなら、Wheelインスタンスの作成を分離し、隔離する。
```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * wheel.diameter
  end

  def wheel
    @wheel ||= Wheel.new(rim, tire)
  end

  def ratio
    chainring / cog.to_f
  end
end
```

これでgear_inchesはWheelに依存しなくなり、使いやすくなった。  
GearがWheelに依存していることも自明になる。  
こういうコードはリファクタリングがしやすく、変化に対応しやすい。

この変更で、外部のクラスへの参照をwheelに隔離したが、外部のメッセージへの参照も隔離したほうがいい。

「外部のメッセージ」とはself以外に送られるメッセージのこと。  
以下のgear_inchesはratioとwheelをselfに送るが、diameterはwheelに送るので、外部メッセージである。
```ruby
def gear_inches
  ratio * wheel.diameter
end
```

このようなコードは変更に弱いため、外部への依存を専用のメソッドに隔離するとよい。
```ruby
def gear_inches
  ratio * diameter
end

def diameter
  wheel.diameter
end
```
こうすると、gear_inchesはselfに送るメッセージにのみ依存するようになる。  
このようなメソッドの切り出しは、コードの重複を防ぐために行われることが多い。  
だが今回は、外部への依存をgear_inchesから取り除くために行った。  
この改善によって、例えばdiameterの名前が変わったとしても、そのことによるGearへの影響はdiameterメソッドのみに限定されるようになった。

### 引数の順番への依存を取り除く

メッセージに引数を渡す必要がある際、その順番に依存するのは望ましくない。  
それでは変更に弱くなってしまう。順番が変わると、メッセージの送り手すべてに変更を加えないといけないから。

引数にハッシュを使うことで、順番への依存を回避できる。  
引数にデフォルト値を設定することも有効。  
引数の受け取り方を変えることが出来ない場合は、そのメッセージへの依存を隔離してしまう。そのメッセージを利用するためのメソッドを1つ作り、そのメソッドが使い勝手のよいインタフェースを提供する。そうすることで、望ましくないインタフェースを持ったメッセージへの依存がアプリケーション全体に広がることを防げる。

依存関係には方向がある。  
例えばGearはWheelに依存しているが、これを逆にして、WheelをGearに依存させることも出来る。  
どちらでも同じ機能を実現させることが出来る。  
だが依存関係の方向は、変更のしやすさに大きな影響を与える。  
そのため、依存関係の方向を正しく決定することが、変更に強いプログラムを作る上で重要になる。

依存関係の方向を決めるための指針はいくつかある。

まず、変更の起きやすさ。  
自分自身が書いたコードだけでなく、言語に組み込まれているコードや他者が開発したフレームワークのコードも含めて、それぞれに変更の起きやすさがある。  
例えば、Ruby に組み込まれているメソッドが変更になる可能性はかなり低いため、そこに依存するのは間違っていない。  

次に、具象クラスと抽象クラスという概念。前者のほうが変更が発生する可能性が高い。  
抽象とは「いかなる特定の実例（インスタンス）からも離れている」こと。  
「依存オブジェクトの注入」で、Gearが依存する対象を「Wheelというクラス」から「diameterメッセージに応答できるオブジェクト」に変化させたが、これは、抽象化の過程と言える。  
当初はWheelという具象的なコードに依存していたが、「diameterメッセージを持つオブジェクト」という抽象的なものに依存するようになった。これによりGearが「いかなる特定の実例（インスタンス）からも離れている」状態になった。  
抽象化されたものは変更が起きにくいため、それへの依存は比較的安全である。

そして、他のクラスからどれくらい依存されているか。  
大量に依存されているクラスの場合、そのクラスに変更があった場合の影響が甚大になる。  
さらに、そういうクラスに対する変更に対して否定的になってしまい、アプリケーションの開発が停滞したり非効率になってしまうというリスクもある。  

上記の要素を組み合わせて、設計を決めることになる。  
例えば、変更が起きやすいクラスがあったとしても、そこに依存しているクラスがほとんど存在しないなら、問題はない。  
問題は、変更が起きやすく、それでいて多くのクラスから依存されているクラス。  
このようなクラスがあると、アプリケーションへの変更が苦痛に満ちたものになってしまう。

「自身より変更されないものに依存しなさい」というルールを心掛けることで、少しずつ設計を改善していくことが出来る。

## 3.4 まとめ

依存オブジェクトの注入によって、再利用性の高い、疎結合なオブジェクトを作ることが出来る。  
依存を隔離することで変更に強くなるし、抽象化されたものに依存することで変更が発生しにくくなる。  
依存方向も重要で、自身より変更の少ないクラスに依存することが、メンテンス性の高いアプリケーションにつながる。
